#!/usr/bin/env python3
"""Generate istota configuration files from a settings TOML file.

Uses only stdlib. Reads a settings file (mirrors Ansible variable names
without the istota_ prefix) and generates:
  - config/config.toml
  - config/users/{user_id}.toml (per user)
  - /etc/istota/admins
  - /etc/istota/secrets.env (if use_environment_file)
  - istota-scheduler.service systemd unit
  - logrotate config
  - Optional: backup script/cron, docker-compose, fava services
"""
from __future__ import annotations

import argparse
import json
import os
import sys
import textwrap
from pathlib import Path

if sys.version_info >= (3, 11):
    import tomllib
else:
    try:
        import tomllib
    except ImportError:
        try:
            import tomli as tomllib  # type: ignore[no-redef]
        except ImportError:
            print("Python 3.11+ required, or install tomli: pip install tomli", file=sys.stderr)
            sys.exit(1)


def load_settings(path: Path) -> dict:
    with open(path, "rb") as f:
        return tomllib.load(f)


def get(settings: dict, key: str, default=None):
    """Get a setting, checking env var override first (ISTOTA_ prefix)."""
    env_key = f"ISTOTA_{key.upper()}"
    env_val = os.environ.get(env_key)
    if env_val is not None:
        return env_val
    parts = key.split(".")
    d = settings
    for p in parts[:-1]:
        d = d.get(p, {})
    return d.get(parts[-1], default)


def tobool(val) -> str:
    if isinstance(val, bool):
        return "true" if val else "false"
    return "true" if str(val).lower() in ("true", "1", "yes") else "false"


def render_config_toml(s: dict) -> str:
    """Render the main config.toml."""
    home = get(s, "home", "/srv/app/istota")
    namespace = get(s, "namespace", "istota")
    bot_name = get(s, "bot_name", namespace.capitalize())
    use_env_file = get(s, "use_environment_file", True)
    mount_path = get(s, "nextcloud_mount_path", "/srv/mount/nextcloud/content")
    use_mount = get(s, "use_nextcloud_mount", True)

    lines = [
        f'# {namespace.capitalize()} configuration - generated by render_config.py',
        '',
        f'bot_name = "{bot_name}"',
        f'db_path = "{home}/data/{namespace}.db"',
    ]

    if use_mount:
        lines.append(f'nextcloud_mount_path = "{mount_path}"')
    lines.append(f'rclone_remote = "{get(s, "rclone_remote", "nextcloud")}"')
    lines.append(f'skills_dir = "{home}/src/config/skills"')
    lines.append(f'temp_dir = "{home}/tmp"')

    # [security]
    lines.extend(['', '[security]'])
    lines.append(f'mode = "{get(s, "security.mode", "restricted")}"')
    lines.append(f'sandbox_enabled = {tobool(get(s, "security.sandbox_enabled", True))}')
    lines.append(f'sandbox_admin_db_write = {tobool(get(s, "security.sandbox_admin_db_write", False))}')

    # [nextcloud]
    lines.extend(['', '[nextcloud]'])
    lines.append(f'url = "{get(s, "nextcloud_url", "")}"')
    lines.append(f'username = "{get(s, "nextcloud_username", namespace)}"')
    if not use_env_file:
        lines.append(f'app_password = "{get(s, "nextcloud_app_password", "")}"')

    # [talk]
    lines.extend(['', '[talk]'])
    lines.append(f'enabled = {tobool(get(s, "talk.enabled", True))}')
    lines.append(f'bot_username = "{get(s, "talk.bot_username", namespace)}"')

    # [email]
    email_enabled = get(s, "email.enabled", False)
    lines.extend(['', '[email]'])
    lines.append(f'enabled = {tobool(email_enabled)}')
    if email_enabled:
        for key in ("imap_host", "imap_port", "imap_user", "smtp_host", "smtp_port", "poll_folder", "bot_email"):
            val = get(s, f"email.{key}", "")
            if isinstance(val, int) or (isinstance(val, str) and val.isdigit()):
                lines.append(f'{key} = {val}')
            else:
                lines.append(f'{key} = "{val}"')
        if not use_env_file:
            lines.append(f'imap_password = "{get(s, "email.imap_password", "")}"')

    # [conversation]
    lines.extend(['', '[conversation]'])
    conv = s.get("conversation", {})
    lines.append(f'enabled = {tobool(conv.get("enabled", True))}')
    lines.append(f'lookback_count = {conv.get("lookback_count", 25)}')
    lines.append(f'selection_model = "{conv.get("selection_model", "haiku")}"')
    lines.append(f'selection_timeout = {conv.get("selection_timeout", 30.0)}')
    lines.append(f'skip_selection_threshold = {conv.get("skip_selection_threshold", 3)}')
    lines.append(f'use_selection = {tobool(conv.get("use_selection", True))}')
    lines.append(f'always_include_recent = {conv.get("always_include_recent", 10)}')
    lines.append(f'context_truncation = {conv.get("context_truncation", 0)}')

    # [logging]
    lines.extend(['', '[logging]'])
    log = s.get("logging", {})
    lines.append(f'level = "{log.get("level", "INFO")}"')
    lines.append(f'output = "{log.get("output", "both")}"')
    lines.append(f'file = "{log.get("file", f"/var/log/{namespace}/{namespace}.log")}"')
    lines.append(f'rotate = {tobool(log.get("rotate", True))}')
    lines.append(f'max_size_mb = {log.get("max_size_mb", 10)}')
    lines.append(f'backup_count = {log.get("backup_count", 5)}')

    # [scheduler]
    lines.extend(['', '[scheduler]'])
    sch = s.get("scheduler", {})
    sched_fields = [
        ("poll_interval", 5), ("talk_poll_interval", 10), ("talk_poll_timeout", 30),
        ("talk_poll_wait", 2.0), ("email_poll_interval", 60), ("briefing_check_interval", 60),
        ("tasks_file_poll_interval", 30), ("shared_file_check_interval", 120),
        ("heartbeat_check_interval", 60), ("progress_updates", True),
        ("progress_min_interval", 8), ("progress_max_messages", 5),
        ("progress_show_tool_use", True), ("progress_show_text", False),
        ("task_timeout_minutes", 30), ("confirmation_timeout_minutes", 120),
        ("stale_pending_warn_minutes", 30), ("stale_pending_fail_hours", 2),
        ("max_retry_age_minutes", 60), ("task_retention_days", 7),
        ("email_retention_days", 7), ("max_foreground_workers", 5),
        ("max_background_workers", 3), ("worker_idle_timeout", 30),
        ("user_max_foreground_workers", 2), ("user_max_background_workers", 1),
        ("scheduled_job_max_consecutive_failures", 5),
        ("feed_check_interval", 300), ("feed_item_retention_days", 30),
    ]
    for key, default in sched_fields:
        val = sch.get(key, default)
        if isinstance(val, bool) or (isinstance(default, bool)):
            lines.append(f'{key} = {tobool(val)}')
        else:
            lines.append(f'{key} = {val}')

    # [briefing_defaults]
    bd = s.get("briefing_defaults", {})
    if bd:
        lines.extend(['', '[briefing_defaults]'])
        if "markets" in bd:
            lines.append('[briefing_defaults.markets]')
            if "futures" in bd["markets"]:
                lines.append(f'futures = {json.dumps(bd["markets"]["futures"])}')
            if "indices" in bd["markets"]:
                lines.append(f'indices = {json.dumps(bd["markets"]["indices"])}')
        if "news" in bd:
            lines.append('[briefing_defaults.news]')
            if "lookback_hours" in bd["news"]:
                lines.append(f'lookback_hours = {bd["news"]["lookback_hours"]}')
            sources = bd["news"].get("sources", [])
            if sources:
                lines.append('sources = [')
                for src in sources:
                    lines.append(f'    {{ type = "{src["type"]}", value = "{src["value"]}" }},')
                lines.append(']')

    # [ntfy]
    if get(s, "ntfy.enabled", False):
        lines.extend(['', '[ntfy]', 'enabled = true'])
        lines.append(f'server_url = "{get(s, "ntfy.server_url", "https://ntfy.sh")}"')
        lines.append(f'topic = "{get(s, "ntfy.topic", "")}"')
        if not use_env_file:
            token = get(s, "ntfy.token", "")
            if token:
                lines.append(f'token = "{token}"')
            username = get(s, "ntfy.username", "")
            if username:
                lines.append(f'username = "{username}"')
                lines.append(f'password = "{get(s, "ntfy.password", "")}"')
        lines.append(f'priority = {get(s, "ntfy.priority", 3)}')

    # [browser]
    if get(s, "browser.enabled", False):
        lines.extend(['', '[browser]', 'enabled = true'])
        lines.append(f'api_url = "http://localhost:{get(s, "browser.api_port", 9223)}"')
        lines.append(f'vnc_url = "{get(s, "browser.vnc_external_url", "")}"')

    # [memory_search]
    if get(s, "memory_search.enabled", True):
        lines.extend(['', '[memory_search]', 'enabled = true'])
        lines.append(f'auto_index_conversations = {tobool(get(s, "memory_search.auto_index_conversations", True))}')
        lines.append(f'auto_index_memory_files = {tobool(get(s, "memory_search.auto_index_memory_files", True))}')

    # [sleep_cycle]
    if get(s, "sleep_cycle.enabled", False):
        lines.extend(['', '[sleep_cycle]', 'enabled = true'])
        lines.append(f'cron = "{get(s, "sleep_cycle.cron", "0 2 * * *")}"')
        lines.append(f'lookback_hours = {get(s, "sleep_cycle.lookback_hours", 24)}')
        lines.append(f'memory_retention_days = {get(s, "sleep_cycle.memory_retention_days", 0)}')

    # [channel_sleep_cycle]
    if get(s, "channel_sleep_cycle.enabled", False):
        lines.extend(['', '[channel_sleep_cycle]', 'enabled = true'])
        lines.append(f'cron = "{get(s, "channel_sleep_cycle.cron", "0 3 * * *")}"')
        lines.append(f'lookback_hours = {get(s, "channel_sleep_cycle.lookback_hours", 24)}')
        lines.append(f'memory_retention_days = {get(s, "channel_sleep_cycle.memory_retention_days", 0)}')

    # [site]
    if get(s, "site.enabled", False):
        lines.extend(['', '[site]', 'enabled = true'])
        lines.append(f'base_path = "{get(s, "site.base_path", f"{home}/html")}"')
        lines.append(f'hostname = "{get(s, "site.hostname", f"{namespace}.example.com")}"')

    # [developer]
    if get(s, "developer.enabled", False):
        lines.extend(['', '[developer]', 'enabled = true'])
        lines.append(f'repos_dir = "{get(s, "developer.repos_dir", "")}"')
        lines.append(f'gitlab_url = "{get(s, "developer.gitlab_url", "https://gitlab.com")}"')
        if not use_env_file:
            lines.append(f'gitlab_token = "{get(s, "developer.gitlab_token", "")}"')
        lines.append(f'gitlab_username = "{get(s, "developer.gitlab_username", "")}"')
        lines.append(f'gitlab_default_namespace = "{get(s, "developer.gitlab_default_namespace", "")}"')
        lines.append(f'gitlab_reviewer_id = "{get(s, "developer.gitlab_reviewer_id", "")}"')
        allowlist = get(s, "developer.gitlab_api_allowlist", [
            "GET /api/v4/projects/*", "GET /api/v4/groups/*", "GET /api/v4/users*",
            "POST /api/v4/projects/*/merge_requests", "POST /api/v4/projects/*/merge_requests/*/notes",
            "POST /api/v4/projects/*/issues", "POST /api/v4/projects/*/issues/*/notes",
            "PUT /api/v4/projects/*/merge_requests/*/merge",
        ])
        lines.append('gitlab_api_allowlist = [')
        for pattern in allowlist:
            lines.append(f'    "{pattern}",')
        lines.append(']')

        # GitHub settings
        github_url = get(s, "developer.github_url", "")
        if github_url:
            lines.append(f'github_url = "{github_url}"')
        else:
            lines.append(f'github_url = "https://github.com"')
        if not use_env_file:
            github_token = get(s, "developer.github_token", "")
            if github_token:
                lines.append(f'github_token = "{github_token}"')
        github_username = get(s, "developer.github_username", "")
        if github_username:
            lines.append(f'github_username = "{github_username}"')
        github_default_owner = get(s, "developer.github_default_owner", "")
        if github_default_owner:
            lines.append(f'github_default_owner = "{github_default_owner}"')
        github_reviewer = get(s, "developer.github_reviewer", "")
        if github_reviewer:
            lines.append(f'github_reviewer = "{github_reviewer}"')

    lines.append('')
    lines.append('# User configuration is in per-user files: config/users/{user_id}.toml')
    lines.append('')
    return "\n".join(lines)


def render_user_toml(user_id: str, user_config: dict) -> str:
    """Render a per-user TOML config file."""
    lines = [f"# {user_id} - generated by render_config.py", ""]
    lines.append(f'display_name = "{user_config.get("display_name", user_id)}"')

    emails = user_config.get("email_addresses", [])
    if emails:
        lines.append(f'email_addresses = {json.dumps(emails)}')

    lines.append(f'timezone = "{user_config.get("timezone", "UTC")}"')

    for field in ("invoicing_notifications", "invoicing_conversation_token", "ntfy_topic"):
        val = user_config.get(field, "")
        if val:
            lines.append(f'{field} = "{val}"')

    if user_config.get("site_enabled", False):
        lines.append("site_enabled = true")

    # Resources
    for resource in user_config.get("resources", []):
        lines.append("")
        lines.append("[[resources]]")
        if resource.get("type") == "karakeep":
            lines.append('type = "karakeep"')
            lines.append(f'name = "{resource.get("name", "Bookmarks")}"')
            lines.append(f'base_url = "{resource.get("base_url", "")}"')
            lines.append(f'api_key = "{resource.get("api_key", "")}"')
        else:
            lines.append(f'type = "{resource["type"]}"')
            lines.append(f'path = "{resource["path"]}"')
            name = resource.get("name", "")
            if name:
                lines.append(f'name = "{name}"')
            lines.append(f'permissions = "{resource.get("permissions", "read")}"')

    # Briefings
    for briefing in user_config.get("briefings", []):
        lines.append("")
        lines.append("[[briefings]]")
        lines.append(f'name = "{briefing["name"]}"')
        lines.append(f'cron = "{briefing["cron"]}"')
        token = briefing.get("conversation_token", "")
        if token:
            lines.append(f'conversation_token = "{token}"')
        lines.append(f'output = "{briefing.get("output", "talk")}"')
        lines.append("")
        lines.append("[briefings.components]")
        components = briefing.get("components", {})
        for key in ("calendar", "todos", "email"):
            if key in components:
                lines.append(f'{key} = {tobool(components[key])}')
        for key in ("markets", "news", "notes", "reminders"):
            if key in components:
                val = components[key]
                if isinstance(val, bool):
                    lines.append(f'{key} = {tobool(val)}')
                elif isinstance(val, dict) and val.get("enabled", False):
                    lines.append(f'{key} = true')
                elif isinstance(val, dict):
                    lines.append(f'{key} = false')

    lines.append("")
    return "\n".join(lines)


def render_admins(admin_users: list) -> str:
    lines = [
        "# Istota admin users - one user ID per line",
        "# Users listed here get full system access (DB, all files, admin-only skills)",
        "# If this file is empty or missing, all users are admins (backward compatible)",
    ]
    for uid in admin_users:
        lines.append(uid)
    lines.append("")
    return "\n".join(lines)


def render_secrets_env(s: dict) -> str:
    lines = ["# Istota secrets - generated by render_config.py",
             "# Loaded via EnvironmentFile= in systemd service"]
    prefix = get(s, "package", "istota").upper()
    pairs = [
        ("nextcloud_app_password", f"{prefix}_NC_APP_PASSWORD"),
        ("email.imap_password", f"{prefix}_IMAP_PASSWORD"),
        ("email.smtp_password", f"{prefix}_SMTP_PASSWORD"),
        ("developer.gitlab_token", f"{prefix}_GITLAB_TOKEN"),
        ("developer.github_token", f"{prefix}_GITHUB_TOKEN"),
        ("ntfy.token", f"{prefix}_NTFY_TOKEN"),
        ("ntfy.password", f"{prefix}_NTFY_PASSWORD"),
    ]
    for setting_key, env_key in pairs:
        val = get(s, setting_key, "")
        # smtp_password falls back to imap_password
        if setting_key == "email.smtp_password" and not val:
            val = get(s, "email.imap_password", "")
        if val:
            lines.append(f"{env_key}={val}")

    # Claude OAuth token
    claude_token = get(s, "claude_oauth_token", "")
    if claude_token:
        lines.append(f"CLAUDE_CODE_OAUTH_TOKEN={claude_token}")

    lines.append("")
    return "\n".join(lines)


def render_systemd_service(s: dict) -> str:
    home = get(s, "home", "/srv/app/istota")
    namespace = get(s, "namespace", "istota")
    package = get(s, "package", "istota")
    user = get(s, "user", namespace)
    group = get(s, "group", namespace)
    use_mount = get(s, "use_nextcloud_mount", True)
    mount_path = get(s, "nextcloud_mount_path", "/srv/mount/nextcloud/content")
    use_env_file = get(s, "use_environment_file", True)

    lines = ["[Unit]"]
    lines.append(f"Description={namespace.capitalize()} Task Scheduler Daemon")
    lines.append("After=network.target")
    if use_mount:
        lines.append("After=mount-nextcloud.service")
        lines.append("Wants=mount-nextcloud.service")

    lines.extend(["", "[Service]"])
    lines.append("Type=simple")
    lines.append(f"User={user}")
    lines.append(f"Group={group}")
    lines.append(f"WorkingDirectory={home}/src")
    lines.append(f"ExecStart={home}/.venv/bin/python -m {package}.scheduler --daemon --config {home}/src/config/config.toml")
    lines.append("Restart=always")
    lines.append("RestartSec=5")
    lines.append("")
    lines.append("# Environment")
    lines.append(f"Environment=PATH={home}/.venv/bin:{home}/.local/bin:/usr/local/bin:/usr/bin:/bin")
    lines.append(f"Environment=HOME={home}")
    lines.append("Environment=PYTHONUNBUFFERED=1")
    lines.append(f"Environment=ISTOTA_ADMINS_FILE=/etc/{namespace}/admins")
    if use_env_file:
        lines.append(f"EnvironmentFile=/etc/{namespace}/secrets.env")
    lines.append("")
    lines.append("# Logging")
    lines.append("StandardOutput=journal")
    lines.append("StandardError=journal")
    lines.append(f"SyslogIdentifier={namespace}-scheduler")
    lines.append("")
    lines.append("# Security hardening")
    lines.append("NoNewPrivileges=true")
    lines.append("ProtectSystem=strict")
    lines.append("ProtectHome=read-only")
    lines.append("PrivateTmp=true")
    lines.append(f"ReadWritePaths={home}")
    lines.append(f"ReadWritePaths=/var/log/{namespace}")
    if use_mount:
        lines.append(f"ReadWritePaths={mount_path}")

    lines.extend(["", "[Install]"])
    lines.append("WantedBy=multi-user.target")
    lines.append("")
    return "\n".join(lines)


def render_logrotate(s: dict) -> str:
    namespace = get(s, "namespace", "istota")
    user = get(s, "user", namespace)
    group = get(s, "group", namespace)
    return textwrap.dedent(f"""\
        /var/log/{namespace}/*.log {{
            daily
            missingok
            rotate 14
            compress
            delaycompress
            notifempty
            copytruncate
            create 0640 {user} {group}
        }}
    """)


def main():
    parser = argparse.ArgumentParser(description="Generate istota configuration files")
    parser.add_argument("--settings", "-s", default="/etc/istota/settings.toml",
                        help="Path to settings TOML file")
    parser.add_argument("--output-dir", "-o", default=".",
                        help="Output directory for generated files")
    parser.add_argument("--dry-run", action="store_true",
                        help="Print what would be generated without writing")
    args = parser.parse_args()

    settings_path = Path(args.settings)
    if not settings_path.exists():
        print(f"Settings file not found: {settings_path}", file=sys.stderr)
        sys.exit(1)

    s = load_settings(settings_path)
    out = Path(args.output_dir)
    home = get(s, "home", "/srv/app/istota")
    namespace = get(s, "namespace", "istota")

    files: dict[str, str] = {}

    # config.toml
    files[f"{home}/src/config/config.toml"] = render_config_toml(s)

    # Per-user config files
    for user_id, user_config in s.get("users", {}).items():
        files[f"{home}/src/config/users/{user_id}.toml"] = render_user_toml(user_id, user_config)

    # Admin users
    files[f"/etc/{namespace}/admins"] = render_admins(s.get("admin_users", []))

    # Secrets env
    if get(s, "use_environment_file", True):
        files[f"/etc/{namespace}/secrets.env"] = render_secrets_env(s)

    # Systemd service
    files["/etc/systemd/system/istota-scheduler.service"] = render_systemd_service(s)

    # Logrotate
    files[f"/etc/logrotate.d/{namespace}"] = render_logrotate(s)

    if args.dry_run:
        for path, content in files.items():
            print(f"=== {path} ===")
            print(content)
            print()
    else:
        for path, content in files.items():
            # Use output-dir as prefix for relative-looking paths, but keep absolute paths
            if path.startswith("/"):
                file_path = out / path.lstrip("/")
            else:
                file_path = out / path
            file_path.parent.mkdir(parents=True, exist_ok=True)
            file_path.write_text(content)
            print(f"  wrote {file_path}")

    print(f"Generated {len(files)} files")


if __name__ == "__main__":
    main()
